
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Email Reader</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #FFECD2 0%, #FCB69F 25%, #FF8A9B 50%, #C9A7EB 75%, #A8D8EA 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px 30px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 800px;
            width: 100%;
            flex-shrink: 0;
        }

        /* Mobile: reduce body padding to give container more width */
        @media (max-width: 768px) {
            body {
                padding: 15px 6px;
            }
            .container {
                padding: 25px;
            }
        }

        .header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        h1 {
            color: #333;
            font-size: 28px;
            margin: 0;
        }

        .logo-image {
            width: 100%;
            max-width: 800px;
            height: auto;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .status {
            background: #E8FFF8;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-text {
            color: #00A8A8;
            font-size: 16px;
        }

        .status-detail {
            color: #1A7A7A;
            font-size: 14px;
            margin-top: 5px;
        }

        .email-display {
            background: #FFF8F5;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .email-header {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #FFD6E0;
        }

        .email-from, .email-to, .email-cc {
            font-weight: 600;
            color: #FF8A9B;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .email-subject {
            font-size: 18px;
            font-weight: 600;
            color: #FF6B9D;
            margin-bottom: 5px;
        }

        .email-date {
            color: #FF8A9B;
            font-size: 14px;
        }

        .email-body {
            color: #FF8A9B;
            line-height: 1.6;
            font-size: 14px;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            word-break: break-word;
            max-height: 300px;
            overflow-x: hidden;
            overflow-y: scroll; /* Changed from auto to always show scrollbar */
            padding-right: 10px;
            scroll-behavior: smooth;
            /* Force scrollbar to always be visible on mobile */
            scrollbar-width: thin;
            scrollbar-color: #FF6B9D #FFD6E0;
        }

        /* Custom scrollbar for webkit browsers (Chrome, Safari, Edge) */
        .email-body::-webkit-scrollbar {
            width: 8px;
            -webkit-appearance: none; /* Force custom scrollbar on iOS */
        }

        .email-body::-webkit-scrollbar-track {
            background: #FFD6E0;
            border-radius: 4px;
        }

        .email-body::-webkit-scrollbar-thumb {
            background: #FF6B9D;
            border-radius: 4px;
            /* Make thumb more visible */
            min-height: 30px;
        }

        .email-body::-webkit-scrollbar-thumb:hover {
            background: #E84C7A;
        }

        /* iOS-specific: ensure scrollbar doesn't auto-hide */
        @supports (-webkit-touch-callout: none) {
            .email-body {
                /* Force persistent scrollbar on iOS */
                -webkit-overflow-scrolling: auto;
            }
        }

        .commands {
            background: #F5F0FF;
            border-radius: 12px;
            padding-top: 5px;
            padding-left: 20px;
            padding-right: 20px;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }

        .commands h3 {
            color: #5A3E8A;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .commands.hidden {
            display: none;
        }

        .command-button {
            background: white;
            border: 2px solid #C9A7EB;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
            width: 100%;
            min-width: 0;
            box-sizing: border-box;
        }

        .command-button:hover {
            border-color: #5A3E8A;
            background: #C9A7EB;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 157, 0.2);
        }

        .command-button:active {
            transform: translateY(0);
        }

        /* Disable sticky hover on touch devices - :active still provides pressed feedback */
        @media (hover: none) {
            .command-button:hover {
                border-color: #C9A7EB;
                background: white;
                transform: none;
                box-shadow: none;
            }
        }

        /* Temporarily disable hover styles on newly-created buttons (for mobile touch) */
        .command-button.no-hover:hover {
            border-color: #C9A7EB;
            background: white;
            transform: none;
            box-shadow: none;
        }

        .command-icon {
            font-size: 22px;
            flex-shrink: 0;
        }

        .command-text {
            flex: 1;
            min-width: 0;
            line-height: 1.3;
        }

        .command-text strong {
            color: #5A3E8A;
            font-size: 11px;
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .command-text small {
            color: #8B6AAE;
            font-size: 10px;
            display: block;
        }

        .hidden {
            display: none !important;
        }

        .setup-instructions {
            background: #E8FFF8;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .setup-instructions h3 {
            color: #00A8A8;
            margin-bottom: 10px;
        }

        .setup-instructions ol {
            margin-left: 20px;
            color: #1A7A7A;
            line-height: 1.8;
        }

        .setup-instructions a {
            color: #FF6B9D;
            text-decoration: none;
            font-weight: 600;
        }

        .setup-instructions a:hover {
            text-decoration: underline;
        }

        .dictation-display {
            background: #F5F0FF;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .dictation-display h3 {
            margin-bottom: 10px;
            color: #5A3E8A;
        }

        .dictation-text {
            color: #5A3E8A;
            font-size: 16px;
            line-height: 1.6;
            min-height: 50px;
            outline: none;
            border: none;
        }

        .dictation-text.disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        #buttonContainer {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        /* Single column for recipient buttons on mobile */
        @media (max-width: 500px) {
            .recipient-button {
                grid-column: 1 / -1;
            }
        }

        .forward-input-container {
            grid-column: 1 / -1;
        }

        .forward-input-container label {
            display: block;
            margin-bottom: 8px;
            color: #5A3E8A;
            font-weight: 600;
        }

        .forward-input-wrapper {
            display: flex;
            gap: 10px;
        }

        .forward-input-wrapper input {
            flex: 1;
            min-width: 0;
            padding: 10px;
            border: 2px solid #C9A7EB;
            border-radius: 8px;
            font-size: 11px;
        }

        .forward-input-wrapper input:focus {
            border-color: #FF6B9D;
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 107, 157, 0.25);
        }

        .forward-input-wrapper .command-button {
            width: auto;
            flex-shrink: 0;
        }

        .attachments-display {
            border-radius: 12px;
            padding: 5px 0px;
            margin-top: 15px;
        }

        .attachments-display h4 {
            color: #FF6B9D;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .attachment-item {
            padding: 5px 0;
            font-size: 13px;
        }

        .attachment-item:last-child {
            margin-bottom: 0;
        }

        .attachment-name {
            color: #FF8A9B;
            font-weight: 500;
        }

        /* Welcome Screen Styles */
        #welcomeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #FFECD2 0%, #FCB69F 25%, #FF8A9B 50%, #C9A7EB 75%, #A8D8EA 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }

        #welcomeScreen.hidden {
            display: none;
        }

        .welcome-content {
            text-align: center;
            padding: 40px;
        }

        .welcome-text {
            margin-top: 40px;
            opacity: 0;
            animation: fadeInUp 0.8s ease-out 0.8s forwards;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-cta {
            font-size: 28px;
            color: white;
            font-weight: 600;
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(255, 255, 255, 0.5);
        }

        .tap-icon {
            font-size: 40px;
            margin-top: 20px;
            animation: pulse 1.5s ease-in-out infinite;
            animation-delay: 1.5s;
            opacity: 0;
            animation-fill-mode: forwards;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Screen - appears after Gmail auth to enable iOS audio -->
    <div id="welcomeScreen">
        <div class="welcome-content">
            <div class="welcome-text">
                <div class="welcome-cta">Tap anywhere to hear your emails.</div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header-row">
            <img src="logo.png" alt="Voice Email Reader" class="logo-image">
        </div>

        <div id="mainSection" class="hidden">
            <div class="status">
                <div class="status-text" id="statusText">Ready to start</div>
                <div class="status-detail" id="statusDetail">Click or say "Start Reading Emails" to begin</div>
            </div>

            <div id="dictationDisplay" class="dictation-display hidden">
                <h3>✍️ Your Message:</h3>
                <div id="dictationText" class="dictation-text" contenteditable="true"></div>
            </div>

            <div id="emailDisplay" class="email-display hidden">
                <div class="email-header">
                    <div class="email-from" id="emailFrom"></div>
                    <div class="email-to" id="emailTo"></div>
                    <div class="email-cc" id="emailCc"></div>
                    <div class="email-subject" id="emailSubject"></div>
                    <div class="email-date" id="emailDate"></div>
                </div>
                <div class="email-body" id="emailBody"></div>
                <div id="attachmentsDisplay" class="attachments-display hidden">
                    <h4>Attachments:</h4>
                    <div id="attachmentsList"></div>
                </div>
            </div>

            <div class="commands" id="commandsSection">
                <h3>Voice Commands:</h3>
                <div id="buttonContainer"></div>
            </div>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script>
        // Configure pdf.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    <script>
        // ============================================================
        // EMAIL VOICE READER - MVC ARCHITECTURE (Version 4.0)
        // ============================================================
        console.log('=== EMAIL VOICE READER VERSION 4.0 (MVC) LOADED ===');

        // ============================================================
        // MODEL - All application state lives here
        // ============================================================
        class EmailReaderModel {
            constructor() {
                // Authentication
                this.clientId = '2680769250-3c7t35tjdqj54jbld3n39bsje5flrlen.apps.googleusercontent.com';
                this.accessToken = null;
                this.userEmail = null;

                // Email state
                this.emails = [];
                this.currentEmailIndex = 0;

                // App state - simple string describing what's happening
                // Possible states: 'initializing', 'welcome', 'idle', 'loading', 'reading', 'dictating',
                //                  'confirming-reply-type', 'confirming-send', 'confirming-forward-recipient',
                //                  'confirming-forward', 'confirming-forward-message'
                this.state = 'initializing';

                // Dictation state
                this.dictatedText = '';
                this.isDictationEditable = true;

                // Forward-specific state
                this.recentRecipients = null;

                // Reply-specific state
                this.isReplyAll = false;

                // Listeners for state changes
                this.listeners = [];
            }

            // Subscribe to state changes
            onChange(callback) {
                this.listeners.push(callback);
            }

            // Notify all listeners of state change
            notify() {
                this.listeners.forEach(cb => cb(this));
            }

            // State setters that auto-notify
            setState(newState) {
                console.log(`State: ${this.state} → ${newState}`);
                this.state = newState;
                this.notify();
            }

            setAccessToken(token) {
                this.accessToken = token;
                this.notify();
            }

            setEmails(emails) {
                this.emails = emails;
                this.notify();
            }

            setCurrentEmailIndex(index) {
                this.currentEmailIndex = index;
                this.notify();
            }

            get currentEmail() {
                return this.emails[this.currentEmailIndex] || null;
            }

            get hasEmail() {
                return this.currentEmail !== null;
            }

            get isAuthenticated() {
                return this.accessToken !== null;
            }

            get hasMoreEmails() {
                return this.currentEmailIndex < this.emails.length - 1;
            }

            get canGoPrevious() {
                return this.currentEmailIndex > 0;
            }
        }

        // ============================================================
        // VIEW - All DOM manipulation lives here
        // ============================================================
        class EmailReaderView {
            constructor() {
                this.elements = {
                    welcomeScreen: document.getElementById('welcomeScreen'),
                    mainSection: document.getElementById('mainSection'),
                    statusText: document.getElementById('statusText'),
                    statusDetail: document.getElementById('statusDetail'),
                    emailDisplay: document.getElementById('emailDisplay'),
                    emailFrom: document.getElementById('emailFrom'),
                    emailTo: document.getElementById('emailTo'),
                    emailCc: document.getElementById('emailCc'),
                    emailSubject: document.getElementById('emailSubject'),
                    emailDate: document.getElementById('emailDate'),
                    emailBody: document.getElementById('emailBody'),
                    dictationDisplay: document.getElementById('dictationDisplay'),
                    dictationText: document.getElementById('dictationText'),
                    buttonContainer: document.getElementById('buttonContainer'),
                    commandsSection: document.getElementById('commandsSection'),
                    attachmentsDisplay: document.getElementById('attachmentsDisplay'),
                    attachmentsList: document.getElementById('attachmentsList')
                };
            }

            // Show/hide welcome screen
            showWelcome() {
                this.elements.welcomeScreen.classList.remove('hidden');
                this.elements.mainSection.classList.add('hidden');
            }

            hideWelcome() {
                this.elements.welcomeScreen.classList.add('hidden');
            }

            showMain() {
                this.elements.welcomeScreen.classList.add('hidden');
                this.elements.mainSection.classList.remove('hidden');
            }

            // Update status display
            updateStatus(text, detail = '') {
                this.elements.statusText.textContent = text;
                this.elements.statusDetail.textContent = detail;
            }

            // Email display
            showEmail(email, gmailUrl, userEmail = null) {
                if (!email || !email.payload || !email.payload.headers) {
                    this.elements.emailFrom.textContent = 'Error loading email';
                    this.elements.emailSubject.textContent = 'Could not load this email';
                    this.elements.emailDate.textContent = '';
                    this.elements.emailBody.textContent = 'This email could not be loaded.';
                    this.elements.emailDisplay.classList.remove('hidden');
                    return;
                }

                const headers = email.payload.headers;
                const fromRaw = this.getHeader(headers, 'From') || 'Unknown';
                const toRaw = this.getHeader(headers, 'To') || '';
                const ccRaw = this.getHeader(headers, 'Cc') || this.getHeader(headers, 'cc') || '';
                const subject = this.getHeader(headers, 'Subject') || 'No subject';
                const date = this.getHeader(headers, 'Date') || '';

                // Replace user's email with "you" for cleaner display
                const from = EmailUtils.replaceUserEmail(fromRaw, userEmail);
                const to = EmailUtils.replaceUserEmail(toRaw, userEmail);
                const cc = EmailUtils.replaceUserEmail(ccRaw, userEmail);

                this.elements.emailFrom.textContent = `From: ${from}`;

                if (to) {
                    this.elements.emailTo.textContent = `To: ${to}`;
                    this.elements.emailTo.style.display = 'block';
                } else {
                    this.elements.emailTo.style.display = 'none';
                }

                if (cc) {
                    this.elements.emailCc.textContent = `CC: ${cc}`;
                    this.elements.emailCc.style.display = 'block';
                } else {
                    this.elements.emailCc.style.display = 'none';
                }

                this.elements.emailSubject.textContent = '';
                const subjectLink = document.createElement('a');
                subjectLink.textContent = subject;
                subjectLink.style.color = '#FF6B9D';
                subjectLink.style.textDecoration = 'none';
                subjectLink.target = '_blank';
                subjectLink.rel = 'noopener noreferrer';
                try {
                    const parsedUrl = new URL(gmailUrl);
                    if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {
                        subjectLink.href = parsedUrl.toString();
                    }
                } catch (e) {
                    // If the URL is invalid, fall back to plain text without a link.
                }
                if (subjectLink.href) {
                    this.elements.emailSubject.appendChild(subjectLink);
                } else {
                    this.elements.emailSubject.textContent = subject;
                }
                this.elements.emailDate.textContent = this.formatDate(date);
                // Display email body with URLs as clickable links (shortened for readability)
                const bodyText = EmailUtils.getEmailBody(email);
                EmailUtils.renderLinkifiedText(this.elements.emailBody, bodyText);
                this.elements.emailBody.scrollTop = 0;
                this.elements.emailDisplay.classList.remove('hidden');
            }

            hideEmail() {
                this.elements.emailDisplay.classList.add('hidden');
            }

            // Attachments display
            showAttachments(attachments) {
                if (!attachments || attachments.length === 0) {
                    this.elements.attachmentsDisplay.classList.add('hidden');
                    return;
                }

                this.elements.attachmentsList.textContent = '';

                attachments.forEach(att => {
                    const item = document.createElement('div');
                    item.className = 'attachment-item';
                    const name = document.createElement('span');
                    name.className = 'attachment-name';
                    name.textContent = att.filename;
                    item.appendChild(name);
                    this.elements.attachmentsList.appendChild(item);
                });

                this.elements.attachmentsDisplay.classList.remove('hidden');
            }

            hideAttachments() {
                this.elements.attachmentsDisplay.classList.add('hidden');
            }

            getHeader(headers, name) {
                const header = headers.find(h => h.name.toLowerCase() === name.toLowerCase());
                return header ? header.value : null;
            }

            formatDate(dateString) {
                if (!dateString) return '';
                try {
                    const date = new Date(dateString);
                    const options = {
                        weekday: 'short', month: 'short', day: 'numeric',
                        year: 'numeric', hour: 'numeric', minute: '2-digit',
                        hour12: true, timeZone: 'America/Los_Angeles'
                    };
                    return date.toLocaleString('en-US', options) + ' PT';
                } catch (e) {
                    return dateString;
                }
            }

            // Dictation display
            showDictation(text = '', editable = true) {
                this.elements.dictationText.textContent = text;
                this.elements.dictationText.contentEditable = editable ? 'true' : 'false';
                if (editable) {
                    this.elements.dictationText.classList.remove('disabled');
                } else {
                    this.elements.dictationText.classList.add('disabled');
                }
                this.elements.dictationDisplay.classList.remove('hidden');
            }

            hideDictation() {
                this.elements.dictationDisplay.classList.add('hidden');
            }

            getDictationText() {
                return this.elements.dictationText.innerText.trim();
            }

            setDictationText(text) {
                this.elements.dictationText.innerText = text;
            }

            appendDictationText(text) {
                const existing = this.getDictationText();
                this.setDictationText(existing ? existing + ' ' + text : text);
            }

            // Command buttons - the key innovation!
            // This renders buttons for ALL available commands automatically
            renderCommands(commands) {
                this.elements.buttonContainer.innerHTML = '';

                if (commands.length === 0) {
                    this.elements.commandsSection.classList.add('hidden');
                    return;
                }

                this.elements.commandsSection.classList.remove('hidden');

                commands.forEach(cmd => {
                    if (cmd.type === 'button') {
                        const button = document.createElement('button');
                        button.className = 'command-button no-hover' + (cmd.isRecipient ? ' recipient-button' : ''); // Start with no-hover to prevent stuck hover on mobile
                        button.onclick = () => {
                            cmd.execute();
                            button.blur(); // Remove focus/hover state after tap (especially for mobile)
                        };
                        button.innerHTML = `
                            <span class="command-icon">${cmd.icon}</span>
                            <span class="command-text">
                                <strong>${cmd.label}</strong>
                                ${cmd.sublabel ? `<small>${cmd.sublabel}</small>` : ''}
                            </span>
                        `;
                        this.elements.buttonContainer.appendChild(button);
                        // Remove no-hover class after a brief delay so hover works normally after touch clears
                        setTimeout(() => button.classList.remove('no-hover'), 300);
                    } else if (cmd.type === 'email-input') {
                        const container = document.createElement('div');
                        container.className = 'forward-input-container';
                        container.innerHTML = `
                            <label>✏️ Or type an email address:</label>
                            <div class="forward-input-wrapper">
                                <input type="email" id="forwardEmailInput" placeholder="someone@example.com" />
                                <button class="command-button no-hover">
                                    <span class="command-icon">✓</span>
                                    <span class="command-text"><strong>Use This</strong></span>
                                </button>
                            </div>
                        `;
                        this.elements.buttonContainer.appendChild(container);

                        // Wire up the button and enter key
                        const input = container.querySelector('input');
                        const useButton = container.querySelector('button');
                        // Remove no-hover class after a brief delay so hover works normally after touch clears
                        setTimeout(() => useButton.classList.remove('no-hover'), 300);
                        useButton.onclick = () => {
                            const email = input.value.trim();
                            if (email && email.includes('@')) {
                                cmd.onSubmit(email);
                            } else {
                                input.style.borderColor = '#FF6B9D';
                                setTimeout(() => input.style.borderColor = '#FFD6E0', 2000);
                            }
                            useButton.blur(); // Remove focus/hover state after tap (especially for mobile)
                        };
                        input.onkeypress = (e) => {
                            if (e.key === 'Enter') useButton.click();
                        };
                    }
                });
            }

            // Scroll email body to a progress percentage (0 to 1)
            // Used for sentence-synchronized scrolling
            scrollToProgress(progress) {
                const el = this.elements.emailBody;
                const totalDistance = el.scrollHeight - el.clientHeight;
                if (totalDistance <= 0) return;

                el.scrollTop = progress * totalDistance;
            }
        }

        // ============================================================
        // EMAIL UTILITIES - Static helper functions
        // ============================================================
        class EmailUtils {
            // Replace user's email address with "you" in address strings
            static replaceUserEmail(addressString, userEmail) {
                if (!userEmail || !addressString) return addressString;

                // Create case-insensitive regex to match the user's email
                const emailRegex = new RegExp(userEmail.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

                // Handle formats like "Name <email>" or just "email"
                // Replace "Name <user@email.com>" with "you"
                // Replace "user@email.com" with "you"
                const result = addressString.split(',').map(addr => {
                    addr = addr.trim();
                    if (emailRegex.test(addr)) {
                        return 'you';
                    }
                    return addr;
                }).join(', ');

                return result;
            }

            static decodeBase64UTF8(base64) {
                try {
                    const binary = atob(base64.replace(/-/g, '+').replace(/_/g, '/'));
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    return new TextDecoder('utf-8').decode(bytes);
                } catch (e) {
                    return atob(base64.replace(/-/g, '+').replace(/_/g, '/'));
                }
            }

            static getEmailBody(email) {
                let body = '';

                if (email.payload) {
                    try {
                        if (email.payload.body && email.payload.body.data) {
                            body = this.decodeBase64UTF8(email.payload.body.data);
                        } else if (email.payload.parts) {
                            let plainPart = null, htmlPart = null;

                            const findParts = (parts) => {
                                for (let part of parts) {
                                    if (part.mimeType === 'text/plain' && part.body?.data && !plainPart) plainPart = part;
                                    if (part.mimeType === 'text/html' && part.body?.data && !htmlPart) htmlPart = part;
                                    if (part.parts) findParts(part.parts);
                                }
                            };

                            findParts(email.payload.parts);
                            const partToUse = plainPart || htmlPart;
                            if (partToUse) {
                                body = this.decodeBase64UTF8(partToUse.body.data);
                            }
                        }
                    } catch (e) {
                        console.error('Error extracting body:', e);
                    }
                }

                if (!body && email.snippet) body = email.snippet;
                if (!body) return 'This email has no readable text content.';

                // Clean HTML/CSS
                body = body.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
                body = body.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
                body = body.replace(/<[^>]*>/g, '');
                body = body.replace(/\{[^}]*\}/g, '');
                body = body.replace(/[a-z-]+\s*:\s*[^;]+\s*!important\s*;?/gi, '');
                // Decode HTML entities (both named like &nbsp; and numeric like &#847; or &#x20;)
                body = body.replace(/&#(\d+);/g, (match, dec) => {
                    const char = String.fromCharCode(dec);
                    // Replace zero-width/invisible characters with nothing
                    if (dec < 32 || (dec >= 127 && dec <= 159) || dec === 847 || dec === 8203 || dec === 8204 || dec === 8205) {
                        return '';
                    }
                    return char;
                });
                body = body.replace(/&#x([0-9a-f]+);/gi, (match, hex) => {
                    const dec = parseInt(hex, 16);
                    if (dec < 32 || (dec >= 127 && dec <= 159) || dec === 847 || dec === 8203 || dec === 8204 || dec === 8205) {
                        return '';
                    }
                    return String.fromCharCode(dec);
                });
                body = body.replace(/&nbsp;/gi, ' ');
                body = body.replace(/&amp;/gi, '&');
                body = body.replace(/&lt;/gi, '<');
                body = body.replace(/&gt;/gi, '>');
                body = body.replace(/&quot;/gi, '"');
                body = body.replace(/&[a-z]+;/gi, ' '); // Any remaining named entities
                body = body.replace(/\s+/g, ' ');
                return body.trim() || 'This email has no text content.';
            }

            static extractFullBody(part) {
                const extract = (p) => {
                    if (p.body && p.body.data) return this.decodeBase64UTF8(p.body.data);
                    if (p.parts) return p.parts.map(extract).join('');
                    return '';
                };
                return extract(part);
            }

            // Strip URLs from text for speech (so URLs aren't read aloud)
            static stripUrlsForSpeech(text) {
                // Remove URLs but keep surrounding text natural
                // Replace URL with nothing, then clean up extra spaces
                return text
                    .replace(/https?:\/\/[^\s<>"]+/gi, '')
                    .replace(/www\.[^\s<>"]+/gi, '')
                    .replace(/\s{2,}/g, ' ')
                    .trim();
            }

            // Convert URLs in text to clickable links for display
            static renderLinkifiedText(container, text) {
                const safeText = text ?? '';
                const urlRegex = /(https?:\/\/[^\s<>"]+)/gi;
                container.textContent = '';

                let lastIndex = 0;
                let match;

                while ((match = urlRegex.exec(safeText)) !== null) {
                    const url = match[0];
                    if (match.index > lastIndex) {
                        container.appendChild(document.createTextNode(safeText.slice(lastIndex, match.index)));
                    }

                    try {
                        const parsed = new URL(url);
                        if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
                            throw new Error('Unsupported protocol');
                        }

                        let displayUrl = parsed.hostname + (parsed.pathname.length > 20
                            ? parsed.pathname.substring(0, 20) + '...'
                            : parsed.pathname);
                        if (!displayUrl) {
                            displayUrl = url.length > 40 ? url.substring(0, 40) + '...' : url;
                        }

                        const link = document.createElement('a');
                        link.href = parsed.toString();
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.style.color = '#FF6B9D';
                        link.style.textDecoration = 'underline';
                        link.textContent = displayUrl;
                        container.appendChild(link);
                    } catch (e) {
                        container.appendChild(document.createTextNode(url));
                    }

                    lastIndex = match.index + url.length;
                }

                if (lastIndex < safeText.length) {
                    container.appendChild(document.createTextNode(safeText.slice(lastIndex)));
                }
            }

            static getHeader(email, name) {
                const header = email.payload?.headers?.find(h => h.name.toLowerCase() === name.toLowerCase());
                return header ? header.value : '';
            }

            static encodeEmail(emailText) {
                return btoa(unescape(encodeURIComponent(emailText)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');
            }

            // Get list of attachments from email
            static getAttachments(email) {
                const attachments = [];

                const findAttachments = (parts) => {
                    if (!parts) return;
                    for (const part of parts) {
                        // Check if this part is an attachment
                        if (part.filename && part.filename.length > 0 && part.body) {
                            attachments.push({
                                filename: part.filename,
                                mimeType: part.mimeType || 'application/octet-stream',
                                size: part.body.size || 0,
                                attachmentId: part.body.attachmentId
                            });
                        }
                        // Recursively check nested parts
                        if (part.parts) {
                            findAttachments(part.parts);
                        }
                    }
                };

                if (email.payload) {
                    // Check root level
                    if (email.payload.filename && email.payload.body?.attachmentId) {
                        attachments.push({
                            filename: email.payload.filename,
                            mimeType: email.payload.mimeType || 'application/octet-stream',
                            size: email.payload.body.size || 0,
                            attachmentId: email.payload.body.attachmentId
                        });
                    }
                    // Check parts
                    findAttachments(email.payload.parts);
                }

                return attachments;
            }

            // Check if attachment is readable (text, PDF, or Word)
            static isReadableAttachment(attachment) {
                const filename = attachment.filename.toLowerCase();
                const mimeType = attachment.mimeType.toLowerCase();

                return filename.endsWith('.txt') ||
                       filename.endsWith('.pdf') ||
                       filename.endsWith('.md') ||
                       filename.endsWith('.csv') ||
                       filename.endsWith('.docx') ||
                       mimeType === 'text/plain' ||
                       mimeType === 'text/csv' ||
                       mimeType === 'text/markdown' ||
                       mimeType === 'application/pdf' ||
                       mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
            }

            // Get human-readable file size
            static formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' bytes';
                if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
                return Math.round(bytes / (1024 * 1024) * 10) / 10 + ' MB';
            }
        }

        // ============================================================
        // SPEECH SERVICE - Text-to-speech and speech recognition
        // Uses sentence chunking for mobile browser compatibility
        // ============================================================
        class SpeechService {
            constructor() {
                this.synthesis = window.speechSynthesis;
                this.recognition = null;
                this.currentUtterance = null;
                this.onCommand = null; // Callback when voice command is heard
                this.isCancelled = false; // Track cancellation for chunked speech
                this.speechGeneration = 0; // Increments each time new speech starts, to invalidate old async loops

                // Resume tracking
                this.remainingSentences = []; // Sentences left to speak when interrupted
                this.canResume = false; // Whether there's something to resume
                this.resumeView = null; // View reference for scroll sync on resume

                // Character-based scroll progress tracking
                this.totalCharacters = 0;
                this.charactersSpoken = 0;
                this.scrollStartThreshold = 0; // Don't scroll until this many chars spoken
                this.scrollableCharacters = 0; // Chars after threshold that map to scroll

                // Wake lock to keep screen on while speaking
                this.wakeLock = null;
                this.wakeLockTimer = null;
                this.wakeLockDelay = 15000; // Keep screen on for 15 seconds after speech ends

                this.initRecognition();
            }

            initRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = false;
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';

                    this.recognition.onresult = (event) => {
                        const command = event.results[0][0].transcript.trim();
                        console.log('Heard:', command);
                        this.cancel(); // Stop any ongoing speech
                        if (this.onCommand) this.onCommand(command);
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                    };

                    this.recognition.onend = () => {
                        // Always restart listening
                        setTimeout(() => this.startListening(), 100);
                    };
                }

                // Backup: When screen turns back on, try to restart voice listening
                // This helps recover if listening stopped while the screen was off
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && this.recognition) {
                        console.log('Screen turned on - ensuring voice listening is active');
                        // Small delay, then try to start (will safely fail if already running)
                        setTimeout(() => this.startListening(), 500);
                    }
                });
            }

            startListening() {
                if (this.recognition) {
                    try {
                        this.recognition.start();
                        return true;
                    } catch (e) {
                        // Already started
                        return false;
                    }
                }
                return false;
            }

            // Wake lock keeps the screen on while the app is reading
            async acquireWakeLock() {
                // Clear any pending release timer since we're speaking again
                if (this.wakeLockTimer) {
                    clearTimeout(this.wakeLockTimer);
                    this.wakeLockTimer = null;
                }

                // Only acquire if we don't already have one
                if (this.wakeLock) return;

                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake lock acquired - screen will stay on');

                        // Handle wake lock being released by the system
                        this.wakeLock.addEventListener('release', () => {
                            console.log('Wake lock released by system');
                            this.wakeLock = null;
                        });
                    }
                } catch (e) {
                    // Wake lock not supported or failed - that's ok, not critical
                    console.log('Wake lock not available:', e.message);
                }
            }

            releaseWakeLockAfterDelay() {
                // Clear any existing timer
                if (this.wakeLockTimer) {
                    clearTimeout(this.wakeLockTimer);
                }

                // Release wake lock after delay (gives user time to respond)
                this.wakeLockTimer = setTimeout(async () => {
                    if (this.wakeLock) {
                        try {
                            await this.wakeLock.release();
                            console.log('Wake lock released - screen can turn off now');
                        } catch (e) {
                            // Already released or error - that's ok
                        }
                        this.wakeLock = null;
                    }
                    this.wakeLockTimer = null;
                }, this.wakeLockDelay);
            }

            // Split text into sentences for mobile compatibility
            // Mobile browsers cut off long utterances, so we chunk by sentence
            splitIntoSentences(text) {
                // Split on sentence-ending punctuation followed by space or end
                // Keep the punctuation with the sentence
                const sentences = text.match(/[^.!?]+[.!?]+[\s]*/g) || [text];
                // Filter out empty strings and trim
                return sentences.map(s => s.trim()).filter(s => s.length > 0);
            }

            // Speak a single chunk (used internally)
            // generation parameter ensures old async loops don't continue after new speech starts
            speakChunk(text, generation) {
                return new Promise((resolve) => {
                    // Check both cancellation flag AND generation to catch stale async loops
                    if (this.isCancelled || generation !== this.speechGeneration) {
                        resolve();
                        return;
                    }

                    this.currentUtterance = new SpeechSynthesisUtterance(text);
                    this.currentUtterance.rate = 1.0;
                    this.currentUtterance.pitch = 1.0;
                    this.currentUtterance.volume = 1.0;

                    this.currentUtterance.onend = () => resolve();
                    this.currentUtterance.onerror = () => resolve();

                    this.synthesis.speak(this.currentUtterance);

                    // Chrome/mobile bug workaround - resume if paused
                    setTimeout(() => {
                        if (this.synthesis.paused) this.synthesis.resume();
                    }, 100);
                });
            }

            // Speak text using chunked sentences for mobile compatibility
            async speak(text, onStart = null, onEnd = null) {
                // Increment generation FIRST to invalidate any old async speech loops
                this.speechGeneration++;
                const myGeneration = this.speechGeneration;

                // Keep screen on while speaking
                this.acquireWakeLock();

                if (this.synthesis.paused) this.synthesis.resume();
                this.synthesis.cancel();
                // Keep isCancelled true during delay so old loops can see it and exit

                await new Promise(r => setTimeout(r, 100)); // Brief delay after cancel

                // NOW safe to reset - old loops have had time to check and exit
                this.isCancelled = false;

                const sentences = this.splitIntoSentences(text);

                if (onStart) onStart();

                for (let i = 0; i < sentences.length; i++) {
                    // Check both flag and generation
                    if (this.isCancelled || myGeneration !== this.speechGeneration) break;
                    await this.speakChunk(sentences[i], myGeneration);
                }

                if (onEnd) onEnd();

                // Allow screen to turn off after a delay (gives user time to respond)
                this.releaseWakeLockAfterDelay();
            }

            // Speak with synchronized scrolling (uses chunked speech for mobile)
            // Scrolls based on character progress through the text
            // scrollStartThreshold: don't scroll until this many characters have been spoken
            async speakWithScroll(text, view, scrollStartThreshold = 0) {
                // Increment generation FIRST to invalidate any old async speech loops
                this.speechGeneration++;
                const myGeneration = this.speechGeneration;

                // Keep screen on while speaking
                this.acquireWakeLock();

                if (this.synthesis.paused) this.synthesis.resume();
                this.synthesis.cancel();
                // Keep isCancelled true during delay so old loops can see it and exit

                await new Promise(r => setTimeout(r, 100)); // Brief delay after cancel

                // NOW safe to reset - old loops have had time to check and exit
                this.isCancelled = false;

                const sentences = this.splitIntoSentences(text);

                // Store for potential resume
                this.allSentences = sentences;
                this.currentSentenceIndex = 0;
                this.resumeView = view;
                this.canResume = true;

                // Calculate total characters for progress-based scrolling
                const totalCharacters = sentences.reduce((sum, s) => sum + s.length, 0);
                let charactersSpoken = 0;

                // Characters that map to scroll (after threshold)
                const scrollableCharacters = Math.max(0, totalCharacters - scrollStartThreshold);

                // Store for resume
                this.totalCharacters = totalCharacters;
                this.scrollStartThreshold = scrollStartThreshold;
                this.scrollableCharacters = scrollableCharacters;
                this.charactersSpoken = 0;

                // Speak all sentences sequentially with synchronized scrolling
                for (let i = 0; i < sentences.length; i++) {
                    // Track current position for resume
                    this.currentSentenceIndex = i;
                    this.charactersSpoken = charactersSpoken;

                    // Check both flag and generation
                    if (this.isCancelled || myGeneration !== this.speechGeneration) break;

                    // Only scroll after passing the threshold (header + buffer)
                    if (charactersSpoken >= scrollStartThreshold && scrollableCharacters > 0) {
                        const scrollProgress = (charactersSpoken - scrollStartThreshold) / scrollableCharacters;
                        view.scrollToProgress(scrollProgress);
                    }

                    await this.speakChunk(sentences[i], myGeneration);
                    charactersSpoken += sentences[i].length;
                }

                // If we finished naturally (not cancelled), clear resume state
                if (!this.isCancelled && myGeneration === this.speechGeneration) {
                    this.canResume = false;
                    this.remainingSentences = [];
                }

                // Allow screen to turn off after a delay (gives user time to respond)
                this.releaseWakeLockAfterDelay();
            }

            cancel() {
                this.isCancelled = true;

                // Save remaining sentences for potential resume
                if (this.allSentences && this.currentSentenceIndex < this.allSentences.length) {
                    this.remainingSentences = this.allSentences.slice(this.currentSentenceIndex);
                    this.canResume = true;
                }

                if (this.synthesis) this.synthesis.cancel();
            }

            // Resume speaking from where we left off, with synchronized scrolling
            async resume() {
                if (!this.canResume || !this.remainingSentences || this.remainingSentences.length === 0) {
                    return false; // Nothing to resume
                }

                // Increment generation to invalidate any old loops
                this.speechGeneration++;
                const myGeneration = this.speechGeneration;

                // Keep screen on while speaking
                this.acquireWakeLock();

                if (this.synthesis.paused) this.synthesis.resume();
                this.synthesis.cancel();

                await new Promise(r => setTimeout(r, 100)); // Brief delay after cancel

                this.isCancelled = false;

                // Restore sentences to speak
                const sentences = this.remainingSentences;
                this.allSentences = sentences;
                this.currentSentenceIndex = 0;

                // Continue character count from where we left off
                let charactersSpoken = this.charactersSpoken || 0;
                const scrollStartThreshold = this.scrollStartThreshold || 0;
                const scrollableCharacters = this.scrollableCharacters || 1;
                const view = this.resumeView;

                // Speak remaining sentences sequentially with synchronized scrolling
                for (let i = 0; i < sentences.length; i++) {
                    this.currentSentenceIndex = i;
                    this.charactersSpoken = charactersSpoken;

                    if (this.isCancelled || myGeneration !== this.speechGeneration) break;

                    // Only scroll after passing the threshold (header + buffer)
                    if (view && charactersSpoken >= scrollStartThreshold && scrollableCharacters > 0) {
                        const scrollProgress = (charactersSpoken - scrollStartThreshold) / scrollableCharacters;
                        view.scrollToProgress(scrollProgress);
                    }

                    await this.speakChunk(sentences[i], myGeneration);
                    charactersSpoken += sentences[i].length;
                }

                // If we finished naturally, clear resume state
                if (!this.isCancelled && myGeneration === this.speechGeneration) {
                    this.canResume = false;
                    this.remainingSentences = [];
                }

                // Allow screen to turn off after a delay (gives user time to respond)
                this.releaseWakeLockAfterDelay();

                return true;
            }

            // Clear resume state (call when moving to a different email)
            clearResumeState() {
                this.canResume = false;
                this.remainingSentences = [];
                this.allSentences = null;
                this.currentSentenceIndex = 0;
                this.charactersSpoken = 0;
                this.totalCharacters = 0;
                this.scrollStartThreshold = 0;
                this.scrollableCharacters = 0;
            }

            get isSpeaking() {
                return this.synthesis.speaking;
            }
        }

        // ============================================================
        // GMAIL SERVICE - All Gmail API calls
        // ============================================================
        class GmailService {
            constructor(model) {
                this.model = model;
                this.SCOPES = 'https://www.googleapis.com/auth/gmail.modify';
            }

            async fetchWithAuth(url, options = {}) {
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        'Authorization': `Bearer ${this.model.accessToken}`,
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                return response;
            }

            async fetchUnreadEmails(maxResults = 10) {
                const response = await this.fetchWithAuth(
                    `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=is:unread in:inbox&maxResults=${maxResults}`
                );
                const data = await response.json();
                if (!data.messages) return [];

                const emails = [];
                for (let msg of data.messages) {
                    try {
                        const emailResponse = await this.fetchWithAuth(
                            `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=full`
                        );
                        if (emailResponse.ok) {
                            emails.push(await emailResponse.json());
                        }
                        await new Promise(r => setTimeout(r, 100)); // Rate limit
                    } catch (e) {
                        console.error(`Error fetching email ${msg.id}:`, e);
                    }
                }
                return emails;
            }

            async modifyEmail(emailId, addLabels = [], removeLabels = []) {
                const body = {};
                if (addLabels.length) body.addLabelIds = addLabels;
                if (removeLabels.length) body.removeLabelIds = removeLabels;

                await this.fetchWithAuth(
                    `https://gmail.googleapis.com/gmail/v1/users/me/messages/${emailId}/modify`,
                    { method: 'POST', body: JSON.stringify(body) }
                );
            }

            async sendEmail(rawEmail, threadId = null) {
                const body = { raw: EmailUtils.encodeEmail(rawEmail) };
                if (threadId) body.threadId = threadId;

                await this.fetchWithAuth(
                    'https://gmail.googleapis.com/gmail/v1/users/me/messages/send',
                    { method: 'POST', body: JSON.stringify(body) }
                );
            }

            async getMyEmail() {
                if (this.model.userEmail) return this.model.userEmail;
                const response = await this.fetchWithAuth(
                    'https://gmail.googleapis.com/gmail/v1/users/me/profile'
                );
                const data = await response.json();
                this.model.userEmail = data.emailAddress || '';
                return this.model.userEmail;
            }

            async getRecentRecipients(maxResults = 6) {
                if (this.model.recentRecipients) return this.model.recentRecipients;

                try {
                    const response = await this.fetchWithAuth(
                        `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=in:sent&maxResults=20`
                    );
                    const data = await response.json();
                    if (!data.messages) return [];

                    const recipients = new Set();
                    const myEmail = await this.getMyEmail();

                    for (let msg of data.messages) {
                        if (recipients.size >= maxResults) break;
                        try {
                            const emailResponse = await this.fetchWithAuth(
                                `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=metadata&metadataHeaders=To&metadataHeaders=Cc`
                            );
                            if (emailResponse.ok) {
                                const email = await emailResponse.json();
                                const to = EmailUtils.getHeader(email, 'To');
                                const cc = EmailUtils.getHeader(email, 'Cc');

                                (to + ',' + cc).split(',')
                                    .map(addr => addr.trim())
                                    .filter(addr => addr && !addr.toLowerCase().includes(myEmail.toLowerCase()))
                                    .filter(addr => {
                                        // Skip unsubscribe emails
                                        const emailMatch = addr.match(/<([^>]+)>/);
                                        const emailAddr = (emailMatch ? emailMatch[1] : addr).toLowerCase();
                                        if (emailAddr.includes('unsubscribe')) return false;
                                        if (emailAddr.startsWith('unsub')) return false;
                                        return true;
                                    })
                                    .forEach(addr => {
                                        if (recipients.size < maxResults) {
                                            const match = addr.match(/<([^>]+)>/);
                                            if ((match ? match[1] : addr).includes('@')) {
                                                recipients.add(addr);
                                            }
                                        }
                                    });
                            }
                            await new Promise(r => setTimeout(r, 50));
                        } catch (e) {}
                    }

                    this.model.recentRecipients = Array.from(recipients);
                    return this.model.recentRecipients;
                } catch (e) {
                    return [];
                }
            }

            async searchForEmail(name) {
                try {
                    const response = await this.fetchWithAuth(
                        `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(name)}&maxResults=10`
                    );
                    const data = await response.json();
                    if (!data.messages) return null;

                    // Prepare spoken words for matching
                    const spokenWords = name.toLowerCase().split(/\s+/).filter(w => w.length > 1);

                    // Check multiple messages to find one that actually matches the query
                    for (const msg of data.messages) {
                        const msgResponse = await this.fetchWithAuth(
                            `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=metadata&metadataHeaders=To&metadataHeaders=From&metadataHeaders=Cc`
                        );
                        const message = await msgResponse.json();

                        const to = EmailUtils.getHeader(message, 'To') || '';
                        const from = EmailUtils.getHeader(message, 'From') || '';
                        const cc = EmailUtils.getHeader(message, 'Cc') || '';
                        const allAddresses = to + ' ' + from + ' ' + cc;

                        // Extract all email addresses with their display names
                        const addressPattern = /(?:([^<,]+)\s*)?<?([\w\.-]+@[\w\.-]+\.\w+)>?/g;
                        let addrMatch;
                        while ((addrMatch = addressPattern.exec(allAddresses)) !== null) {
                            const displayName = (addrMatch[1] || '').trim();
                            const email = addrMatch[2];
                            const emailUsername = email.split('@')[0].replace(/[._]/g, ' ');
                            const searchText = (displayName + ' ' + emailUsername).toLowerCase();

                            // Check if any spoken word matches this address
                            for (const word of spokenWords) {
                                if (searchText.includes(word)) {
                                    return email; // Found a validated match!
                                }
                            }
                        }
                    }

                    // No validated match found in any of the results
                    return null;
                } catch (e) {
                    return null;
                }
            }

            initAuth(onSuccess, onError) {
                // Check if Google Identity Services loaded
                if (typeof google === 'undefined' || !google.accounts) {
                    console.error('Google Identity Services not loaded');
                    if (onError) onError('Google sign-in is not available. Please check if content blockers are disabled for this site.');
                    return;
                }

                try {
                    google.accounts.id.initialize({
                        client_id: this.model.clientId,
                        callback: () => {}
                    });

                    const tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: this.model.clientId,
                        scope: this.SCOPES,
                        callback: (response) => {
                            if (response.access_token) {
                                this.model.setAccessToken(response.access_token);
                                onSuccess();
                            } else if (response.error) {
                                console.error('OAuth error:', response.error);
                                if (onError) onError('Sign-in failed: ' + response.error);
                            }
                        },
                        error_callback: (error) => {
                            console.error('OAuth error callback:', error);
                            if (onError) onError('Sign-in error: ' + (error.message || 'Unknown error'));
                        }
                    });

                    tokenClient.requestAccessToken();
                } catch (e) {
                    console.error('initAuth exception:', e);
                    if (onError) onError('Sign-in initialization failed: ' + e.message);
                }
            }

            signOut() {
                google.accounts.id.disableAutoSelect();
                this.model.setAccessToken(null);
            }

            // Fetch attachment data
            async getAttachment(messageId, attachmentId) {
                const response = await this.fetchWithAuth(
                    `https://gmail.googleapis.com/gmail/v1/users/me/messages/${messageId}/attachments/${attachmentId}`
                );
                if (response.ok) {
                    const data = await response.json();
                    return data.data; // Base64 encoded attachment data
                }
                return null;
            }

            // Extract text from attachment
            async extractAttachmentText(messageId, attachment) {
                const base64Data = await this.getAttachment(messageId, attachment.attachmentId);
                if (!base64Data) {
                    return { success: false, error: 'Could not download attachment' };
                }

                const filename = attachment.filename.toLowerCase();
                const mimeType = attachment.mimeType.toLowerCase();

                try {
                    // Handle text files
                    if (filename.endsWith('.txt') || filename.endsWith('.md') || filename.endsWith('.csv') ||
                        mimeType === 'text/plain' || mimeType === 'text/csv' || mimeType === 'text/markdown') {
                        const text = EmailUtils.decodeBase64UTF8(base64Data);
                        return { success: true, text: text };
                    }

                    // Handle PDF files
                    if (filename.endsWith('.pdf') || mimeType === 'application/pdf') {
                        return await this.extractPdfText(base64Data);
                    }

                    // Handle Word documents (.docx)
                    if (filename.endsWith('.docx') ||
                        mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                        return await this.extractDocxText(base64Data);
                    }

                    return { success: false, error: 'Unsupported file type' };
                } catch (e) {
                    console.error('Error extracting attachment text:', e);
                    return { success: false, error: 'Failed to read attachment' };
                }
            }

            // Extract text from PDF using pdf.js
            async extractPdfText(base64Data) {
                try {
                    // Check if pdf.js is loaded
                    if (typeof pdfjsLib === 'undefined') {
                        return { success: false, error: 'PDF reader not available' };
                    }

                    // Convert base64 to Uint8Array
                    const binaryString = atob(base64Data.replace(/-/g, '+').replace(/_/g, '/'));
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    // Load the PDF
                    const pdf = await pdfjsLib.getDocument({ data: bytes }).promise;
                    let fullText = '';

                    // Extract text from each page
                    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                        const page = await pdf.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + '\n\n';
                    }

                    if (fullText.trim().length === 0) {
                        return { success: false, error: 'PDF appears to be image-based or empty. Cannot extract text.' };
                    }

                    return { success: true, text: fullText.trim() };
                } catch (e) {
                    console.error('PDF extraction error:', e);
                    return { success: false, error: 'Failed to read PDF file' };
                }
            }

            // Extract text from Word document using mammoth.js
            async extractDocxText(base64Data) {
                try {
                    // Check if mammoth is loaded
                    if (typeof mammoth === 'undefined') {
                        return { success: false, error: 'Word document reader not available' };
                    }

                    // Convert base64 to ArrayBuffer
                    const binaryString = atob(base64Data.replace(/-/g, '+').replace(/_/g, '/'));
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const arrayBuffer = bytes.buffer;

                    // Extract text using mammoth
                    const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });

                    if (result.value && result.value.trim().length > 0) {
                        return { success: true, text: result.value.trim() };
                    } else {
                        return { success: false, error: 'Word document appears to be empty or contains only images.' };
                    }
                } catch (e) {
                    console.error('Word document extraction error:', e);
                    return { success: false, error: 'Failed to read Word document' };
                }
            }
        }

        // ============================================================
        // CONTROLLER - Coordinates everything, defines commands
        // ============================================================
        class EmailReaderController {
            constructor(model, view, gmail, speech) {
                this.model = model;
                this.view = view;
                this.gmail = gmail;
                this.speech = speech;

                // Pending promise resolver for multi-step flows
                this.pendingResolver = null;
                this.dictationTimeout = null;

                // Wire up speech recognition
                this.speech.onCommand = (cmd) => this.handleCommand(cmd);

                // Wire up model changes to view updates
                this.model.onChange(() => this.updateView());

                // Wire up dictation input events
                this.view.elements.dictationText.addEventListener('input', () => {
                    this.resetDictationTimeout();
                });
            }

            // ========== COMMAND SYSTEM ==========
            // Each command knows when it's available via isAvailable()
            // The view automatically shows buttons for available commands

            getAvailableCommands() {
                const m = this.model;
                const commands = [];

                // Define all possible commands with their availability conditions
                const allCommands = [
                    // Email action commands (only when viewing an email)
                    {
                        id: 'markread', icon: '✓', label: 'Mark as Read',
                        voiceMatch: (cmd) => this.matchMarkAsRead(cmd),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state),
                        execute: () => this.markAsRead()
                    },
                    {
                        id: 'archive', icon: '📦', label: 'Archive',
                        voiceMatch: (cmd) => cmd.includes('archive') || cmd.includes('Are by') || cmd.includes('barberry'),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state),
                        execute: () => this.archiveEmail()
                    },
                    {
                        id: 'reply', icon: '↩️', label: 'Reply',
                        voiceMatch: (cmd) => cmd.includes('respond') || cmd.includes('reply'),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state),
                        execute: () => this.handleReply()
                    },
                    {
                        id: 'forward', icon: '➡️', label: 'Forward',
                        voiceMatch: (cmd) => cmd.includes('forward'),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state),
                        execute: () => this.handleForward()
                    },
                    {
                        id: 'next', icon: '⏭️', label: 'Next',
                        voiceMatch: (cmd) => cmd.includes('next') || cmd.includes('skip'),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state),
                        execute: () => this.nextEmail()
                    },
                    {
                        id: 'previous', icon: '⏮️', label: 'Previous',
                        voiceMatch: (cmd) => cmd.includes('previous') || cmd.includes('back'),
                        isAvailable: () => m.hasEmail && m.canGoPrevious && ['reading', 'idle'].includes(m.state),
                        execute: () => this.previousEmail()
                    },
                    {
                        id: 'unsubscribe', icon: '🚫', label: 'Unsubscribe',
                        voiceMatch: (cmd) => cmd.includes('unsubscribe'),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state),
                        execute: () => this.handleUnsubscribe()
                    },
                    {
                        id: 'spam', icon: '⚠️', label: 'Spam',
                        voiceMatch: (cmd) => cmd.includes('spam') || cmd.includes('mark as spam') || cmd.includes('mark spam'),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state),
                        execute: () => this.markAsSpam()
                    },
                    {
                        id: 'attachments', icon: '📎', label: 'Read Attachments',
                        voiceMatch: (cmd) => cmd.includes('attachment') || cmd.includes('read file') || cmd.includes('read document'),
                        isAvailable: () => m.hasEmail && ['reading', 'idle'].includes(m.state) && this.hasReadableAttachments(),
                        execute: () => this.readAttachments()
                    },
                    // Main control commands
                    {
                        id: 'start', icon: '▶️', label: 'Play',
                        voiceMatch: (cmd) => cmd.includes('start') || cmd.includes('play') || cmd.includes('begin'),
                        isAvailable: () => m.isAuthenticated && (m.state === 'idle' || m.state === 'reading') && !m.hasEmail,
                        execute: () => this.startReading()
                    },
                    {
                        id: 'stop', icon: '⏹️', label: 'Stop',
                        voiceMatch: (cmd) => cmd.includes('stop') || cmd.includes('pause') || cmd.includes('wait') || cmd.includes('hold on'),
                        isAvailable: () => ['reading', 'reading-attachment'].includes(m.state) && m.hasEmail,
                        execute: () => this.stopReading()
                    },
                    {
                        id: 'continue', icon: '▶️', label: 'Play',
                        voiceMatch: (cmd) => cmd.includes('continue') || cmd.includes('play') || cmd.includes('keep reading') || cmd.includes('finish reading') || cmd.includes('continue reading') || cmd.includes('continue email') || cmd.includes('finish reading email') || cmd.includes('keep reading email'),
                        isAvailable: () => m.state === 'idle' && m.hasEmail,
                        execute: () => this.continueReading()
                    },
                    {
                        id: 'signout', icon: '🚪', label: 'Sign Out',
                        voiceMatch: (cmd) => cmd.includes('sign out') || cmd.includes('logout'),
                        isAvailable: () => m.isAuthenticated && ['idle', 'reading'].includes(m.state),
                        execute: () => this.signOut()
                    },

                    

                    // Confirmation commands (for multi-step flows)
                    {
                        id: 'yes', icon: '✓', label: 'Yes',
                        voiceMatch: (cmd) => cmd.includes('yes'),
                        isAvailable: () => ['confirming-forward', 'confirming-forward-message'].includes(m.state),
                        execute: () => this.resolvePending('yes')
                    },
                    {
                        id: 'no', icon: '✗', label: 'No',
                        voiceMatch: (cmd) => cmd.includes('no'),
                        isAvailable: () => ['confirming-forward', 'confirming-forward-message'].includes(m.state),
                        execute: () => this.resolvePending('no')
                    },
                    {
                        id: 'reply-sender', icon: '👤', label: 'Sender Only',
                        voiceMatch: (cmd) => cmd.includes('reply') && !cmd.includes('all') || cmd.includes('sender only') || cmd.includes('only sender'),
                        isAvailable: () => m.state === 'confirming-reply-type',
                        execute: () => this.resolvePending('reply')
                    },
                    {
                        id: 'reply-all', icon: '👥', label: 'All',
                        voiceMatch: (cmd) => cmd.includes('all'),
                        isAvailable: () => m.state === 'confirming-reply-type',
                        execute: () => this.resolvePending('reply all')
                    },
                    {
                        id: 'send', icon: '🚀', label: 'Send',
                        voiceMatch: (cmd) => cmd.includes('send') || cmd.includes('stand') || cmd.includes('stands') || cmd.includes('sends'),
                        isAvailable: () => m.state === 'confirming-send',
                        execute: () => this.resolvePending('send')
                    },
                    {
                        id: 'edit', icon: '✏️', label: 'Edit',
                        voiceMatch: (cmd) => cmd.includes('edit'),
                        isAvailable: () => m.state === 'confirming-send',
                        execute: () => this.resolvePending('edit')
                    },
                    {
                        id: 'cancel', icon: '✗', label: 'Cancel',
                        voiceMatch: (cmd) => cmd.includes('cancel'),
                        isAvailable: () => ['confirming-send', 'confirming-forward-recipient'].includes(m.state),
                        execute: () => this.resolvePending('cancel')
                    }
                ];

                // Filter to only available commands and format for view
                for (const cmd of allCommands) {
                    if (cmd.isAvailable()) {
                        const originalExecute = cmd.execute;
                        commands.push({
                            type: 'button',
                            id: cmd.id,
                            icon: cmd.icon,
                            label: cmd.label,
                            execute: () => {
                                this.speech.cancel(); // Stop any ongoing speech immediately
                                originalExecute();
                            }
                        });
                    }
                }

                // Special case: forward recipient selection
                if (m.state === 'confirming-forward-recipient' && m.recentRecipients) {
                    for (const recipient of m.recentRecipients) {
                        const match = recipient.match(/<([^>]+)>/);
                        const email = match ? match[1] : recipient;
                        const name = match ? recipient.replace(/<[^>]+>/, '').trim() : '';

                        commands.push({
                            type: 'button',
                            icon: '👤',
                            label: name || email,
                            sublabel: email,
                            isRecipient: true,
                            execute: () => {
                                this.speech.cancel(); // Stop any ongoing speech immediately
                                this.resolvePending(recipient);
                            }
                        });
                    }

                    commands.push({
                        type: 'email-input',
                        onSubmit: (email) => {
                            this.speech.cancel(); // Stop any ongoing speech immediately
                            this.resolvePending(email);
                        }
                    });
                }

                // Store commands for voice matching
                this.currentCommands = allCommands.filter(c => c.isAvailable());

                return commands;
            }

            matchMarkAsRead(cmd) {
                return cmd.includes('marcus red') || cmd.includes('marcus read') ||
                       cmd.includes('march is red') || cmd.includes('march is read') ||
                       cmd.includes('march as red') || cmd.includes('march as read') ||
                       cmd.includes('mark read') || cmd.includes('mark red') ||
                       cmd.includes('mark as read') || cmd.includes('mark as red') ||
                       cmd.includes('mark is red') || cmd.includes('mark is read') ||
                       cmd === 'read' || cmd === 'red';
            }

            handleCommand(spokenCommand) {
                this.view.updateStatus('I heard you say:', `"${spokenCommand}"`);

                // Special handling for dictation mode
                if (this.model.state === 'dictating') {
                    this.view.appendDictationText(spokenCommand);
                    this.resetDictationTimeout();
                    return;
                }

                // Special handling for forward recipient voice search
                if (this.model.state === 'confirming-forward-recipient') {
                    if (spokenCommand.toLowerCase().includes('cancel')) {
                        this.resolvePending('cancel');
                        return;
                    }
                    // Search for the spoken name
                    this.searchAndSelectRecipient(spokenCommand);
                    return;
                }

                // Find matching command from available commands (use lowercase for case-insensitive matching)
                const spokenLower = spokenCommand.toLowerCase();
                for (const cmd of this.currentCommands || []) {
                    if (cmd.voiceMatch && cmd.voiceMatch(spokenLower)) {
                        cmd.execute();
                        return;
                    }
                }

                // No match
                // If we were reading, change state to idle so Continue button appears
                if (this.model.state === 'reading' && this.model.hasEmail) {
                    this.model.setState('idle');
                    this.view.updateStatus('Stopped reading', 'Say "play" to continue');
                }
                this.speech.speak('I did not understand that command. Please try again.');
            }

            // Match spoken words against a list of recipients
            // Returns the best matching recipient or null
            findMatchingRecipient(spokenName, recipients) {
                if (!recipients || !recipients.length) return null;

                const spokenWords = spokenName.toLowerCase().split(/\s+/).filter(w => w.length > 1);
                if (!spokenWords.length) return null;

                let bestMatch = null;
                let bestScore = 0;

                for (const recipient of recipients) {
                    // Parse "Name <email>" format
                    const angleMatch = recipient.match(/<([^>]+)>/);
                    const email = angleMatch ? angleMatch[1] : recipient;
                    const displayName = angleMatch ? recipient.replace(/<[^>]+>/, '').trim() : '';

                    // Get searchable text (name + email username)
                    const emailUsername = email.split('@')[0].replace(/[._]/g, ' ');
                    const searchText = (displayName + ' ' + emailUsername).toLowerCase();

                    // Score: how many spoken words appear in the recipient?
                    let score = 0;
                    for (const word of spokenWords) {
                        if (searchText.includes(word)) {
                            score++;
                        }
                    }

                    // Require at least one word to match
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = recipient;
                    }
                }

                return bestMatch;
            }

            async searchAndSelectRecipient(spokenName) {
                // First, try to match against displayed recipients (fast and reliable)
                const localMatch = this.findMatchingRecipient(spokenName, this.model.recentRecipients);
                if (localMatch) {
                    this.view.updateStatus('Found match', spokenName);
                    this.resolvePending(localMatch);
                    return;
                }

                // Fall back to Gmail search with validation
                this.view.updateStatus('Searching...', `Looking for ${spokenName}`);
                const foundEmail = await this.gmail.searchForEmail(spokenName);

                if (foundEmail) {
                    this.resolvePending(foundEmail);
                } else {
                    this.speech.speak(`I could not find anyone matching ${spokenName}. Please try again, click a recent recipient, or type the email address.`);
                    this.view.updateStatus('Choose recipient');
                }
            }

            // ========== VIEW UPDATE ==========
            updateView() {
                const m = this.model;

                // During initialization, keep welcome screen visible and don't show main
                // This prevents the main UI from flashing before OAuth completes
                if (m.state === 'initializing' || m.state === 'welcome') {
                    return;
                }
                this.view.showMain();

                // Show/hide email display
                if (m.hasEmail) {
                    const gmailUrl = `https://mail.google.com/mail/u/0/#inbox/${m.currentEmail.threadId}`;
                    this.view.showEmail(m.currentEmail, gmailUrl, m.userEmail);
                    // Show attachments if any
                    const attachments = EmailUtils.getAttachments(m.currentEmail);
                    this.view.showAttachments(attachments);
                } else {
                    this.view.hideEmail();
                    this.view.hideAttachments();
                }

                // Show/hide dictation
                if (['dictating', 'confirming-send'].includes(m.state)) {
                    this.view.showDictation(m.dictatedText, m.state === 'dictating');
                } else {
                    this.view.hideDictation();
                }

                // Render available commands
                this.view.renderCommands(this.getAvailableCommands());
            }

            // ========== PENDING PROMISE HELPERS ==========
            resolvePending(value) {
                if (this.pendingResolver) {
                    const resolver = this.pendingResolver;
                    this.pendingResolver = null;
                    resolver(value);
                }
            }

            waitForResponse() {
                return new Promise(resolve => {
                    this.pendingResolver = resolve;
                });
            }

            // ========== DICTATION HELPERS ==========
            resetDictationTimeout() {
                if (this.dictationTimeout) clearTimeout(this.dictationTimeout);
                this.dictationTimeout = setTimeout(() => {
                    const text = this.view.getDictationText();
                    if (text) {
                        this.model.dictatedText = text;
                        this.finishDictation();
                    }
                }, 4000);
            }

            finishDictation() {
                if (this.dictationTimeout) clearTimeout(this.dictationTimeout);
                this.model.dictatedText = this.view.getDictationText();
                if (this.pendingResolver) {
                    this.resolvePending(this.model.dictatedText);
                }
            }

            // ========== INITIALIZATION ==========
            init() {
                // Set up welcome screen click handler
                this.view.elements.welcomeScreen.addEventListener('click', () => this.onWelcomeScreenTap());
                this.view.elements.welcomeScreen.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.onWelcomeScreenTap();
                });

                // Start OAuth flow - Client ID is embedded in the app
                this.gmail.initAuth(
                    async () => {
                        // Pre-fetch user email so we can say "you" instead of their address
                        await this.gmail.getMyEmail();
                        // Show welcome screen (requires tap to enable audio on iOS)
                        this.model.setState('welcome');
                    },
                    (errorMsg) => {
                        // OAuth failed - show error on welcome screen
                        console.error('Auth failed:', errorMsg);
                        const ctaEl = document.querySelector('.welcome-cta');
                        if (ctaEl) {
                            ctaEl.innerHTML = '⚠️ ' + errorMsg + '<br><br>Try opening in Chrome, or disable content blockers in Safari settings.';
                            ctaEl.style.fontSize = '20px';
                        }
                    }
                );
            }

            // Handle tap on welcome screen - this user gesture enables iOS audio
            // CRITICAL: The first speech.speak() call MUST be synchronous within this handler
            // to unlock iOS audio. All async work happens AFTER the welcome message.
            onWelcomeScreenTap() {
                if (this.model.state !== 'welcome') return;

                // Update UI immediately
                this.model.setState('loading');
                this.view.updateStatus('Fetching your emails...', 'One moment please');

                // CRITICAL: This synchronous speech.speak() call unlocks iOS audio.
                // Do NOT add any await/async before this line!
                this.speech.speak('Welcome to Voice Email Reader! Let me check your inbox.').then(async () => {
                    // Audio is now unlocked - safe to do async operations
                    this.speech.startListening();

                    try {
                        // Fetch emails
                        const emails = await this.gmail.fetchUnreadEmails();
                        this.model.setEmails(emails);

                        if (emails.length === 0) {
                            this.view.updateStatus('No unread emails', 'Your inbox is empty!');
                            this.model.setState('idle');
                            this.speech.speak('You have no unread emails. Great job!');
                        } else {
                            this.view.updateStatus(`Found ${emails.length} unread emails`, 'Starting to read...');
                            this.model.setState('reading');
                            this.readCurrentEmail();
                        }
                    } catch (error) {
                        console.error('Error fetching emails:', error);
                        this.view.updateStatus('Error', 'Could not fetch emails. Please try again.');
                        this.model.setState('idle');
                        this.speech.speak('Sorry, I had trouble fetching your emails. Please try again.');
                    }
                });
            }

            signOut() {
                this.gmail.signOut();
                this.model.emails = [];
                this.model.currentEmailIndex = 0;
                this.model.setState('idle');
                this.view.updateStatus('Signed out', 'Please refresh the page to sign in again');
            }

            // ========== EMAIL READING ==========
            async startReading() {
                if (!this.model.isAuthenticated) return;

                this.model.setCurrentEmailIndex(0);
                this.model.setState('loading');
                this.view.updateStatus('Fetching unread emails...');

                const emails = await this.gmail.fetchUnreadEmails();
                this.model.setEmails(emails);

                if (emails.length === 0) {
                    this.view.updateStatus('No unread emails', 'Your inbox is empty!');
                    this.model.setState('idle');
                    this.speech.speak('You have no unread emails. Great job!');
                } else {
                    this.view.updateStatus(`Found ${emails.length} unread emails`, 'Starting to read...');
                    this.model.setState('reading');
                    this.readCurrentEmail();
                }
            }

            stopReading() {
                this.speech.cancel();
                if (this.model.hasEmail) {
                    this.model.setState('idle');
                    this.view.updateStatus('Stopped reading', 'Say "play" to continue');
                } else {
                    this.model.setState('idle');
                    this.view.updateStatus('Stopped');
                }
            }

            async continueReading() {
                if (this.speech.canResume) {
                    this.model.setState('reading');
                    this.view.updateStatus('Continuing email...');
                    await this.speech.resume();
                    // After resume finishes (or is interrupted again), update state
                    if (!this.speech.isCancelled) {
                        this.model.setState('idle');
                        this.view.updateStatus('Finished reading', 'What would you like to do with this email?');
                    }
                } else if (this.model.hasEmail) {
                    // No resume state but we have an email - restart from beginning
                    await this.speech.speak('Starting email from the beginning.');
                    this.readCurrentEmail();
                } else {
                    await this.speech.speak('No email to continue. Say "start" to check for new emails.');
                }
            }

            async readCurrentEmail() {
                const email = this.model.currentEmail;
                if (!email) {
                    await this.checkForMoreEmails();
                    return;
                }

                this.model.setState('reading');
                this.view.updateStatus('Reading email aloud...');

                const fromRaw = EmailUtils.getHeader(email, 'From') || 'Unknown sender';
                const toRaw = EmailUtils.getHeader(email, 'To') || '';
                const ccRaw = EmailUtils.getHeader(email, 'Cc') || '';
                const subject = EmailUtils.getHeader(email, 'Subject') || 'No subject';
                const body = EmailUtils.getEmailBody(email);

                // Replace user's email with "you" for natural speech
                const userEmail = this.model.userEmail;
                const from = EmailUtils.replaceUserEmail(fromRaw, userEmail);
                const to = EmailUtils.replaceUserEmail(toRaw, userEmail);
                const cc = EmailUtils.replaceUserEmail(ccRaw, userEmail);

                // Get attachments
                const attachments = EmailUtils.getAttachments(email);
                const readableAttachments = attachments.filter(a => EmailUtils.isReadableAttachment(a));

                // Build speech text
                let headerText = `From ${from}.`;
                if (to) {
                    const toAddrs = to.split(',').map(a => a.trim());
                    headerText += toAddrs.length <= 3
                        ? ` To: ${toAddrs.join(', ')}.`
                        : ` To: ${toAddrs.slice(0, 3).join(', ')}, and ${toAddrs.length - 3} others.`;
                }
                if (cc) {
                    const ccAddrs = cc.split(',').map(a => a.trim());
                    headerText += ccAddrs.length <= 3
                        ? ` CC: ${ccAddrs.join(', ')}.`
                        : ` CC: ${ccAddrs.slice(0, 3).join(', ')}, and ${ccAddrs.length - 3} others.`;
                }
                headerText += ` Subject: ${subject}.`;

                // Strip URLs from body for speech (so links aren't read aloud)
                const bodyForSpeech = EmailUtils.stripUrlsForSpeech(body);

                // Add attachment announcement after the body
                let attachmentText = '';
                if (attachments.length > 0) {
                    const attachmentNames = attachments.map(a => a.filename).join(', ');
                    if (attachments.length === 1) {
                        attachmentText += ` This email has 1 attachment: ${attachmentNames}.`;
                    } else {
                        attachmentText += ` This email has ${attachments.length} attachments: ${attachmentNames}.`;
                    }
                    if (readableAttachments.length > 0) {
                        attachmentText += ` Say "read attachments" to hear ${readableAttachments.length === 1 ? 'it' : 'them'}.`;
                    }
                }

                const fullText = headerText + ' ' + bodyForSpeech + attachmentText;

                // Delay scrolling until header is read plus ~40 words (~200 chars) into body
                const scrollStartThreshold = headerText.length + 200;

                await this.speech.speakWithScroll(fullText, this.view, scrollStartThreshold);
            }

            async checkForMoreEmails() {
                this.model.setState('loading');
                this.view.updateStatus('Checking for more emails...');

                const seenIds = new Set(this.model.emails.map(e => e.id));
                const newEmails = await this.gmail.fetchUnreadEmails();
                const unseenEmails = newEmails.filter(e => !seenIds.has(e.id));

                if (unseenEmails.length > 0) {
                    this.model.setEmails(unseenEmails);
                    this.model.setCurrentEmailIndex(0);
                    this.model.setState('reading');
                    await this.speech.speak(`Found ${unseenEmails.length} more unread emails. Continuing.`);
                    this.readCurrentEmail();
                } else {
                    await this.speech.speak('You have reached the end of your unread emails. Great job!');
                    this.model.setState('idle');
                }
            }

            async nextEmail() {
                this.speech.clearResumeState(); // Clear resume state when changing emails
                await this.speech.speak('Moving to next email.');
                this.model.setCurrentEmailIndex(this.model.currentEmailIndex + 1);
                this.readCurrentEmail();
            }

            async previousEmail() {
                if (this.model.canGoPrevious) {
                    this.speech.clearResumeState(); // Clear resume state when changing emails
                    await this.speech.speak('Going back to previous email.');
                    this.model.setCurrentEmailIndex(this.model.currentEmailIndex - 1);
                    this.readCurrentEmail();
                } else {
                    await this.speech.speak('This is the first email. Cannot go back.');
                }
            }

            // ========== EMAIL ACTIONS ==========
            async markAsRead() {
                this.speech.clearResumeState(); // Clear resume state when taking action on email
                this.view.updateStatus('Marking as read...');
                try {
                    await this.gmail.modifyEmail(this.model.currentEmail.id, [], ['UNREAD']);
                    await this.speech.speak('Email marked as red.'); // Intentional: "red" not "read" for correct TTS pronunciation
                    this.model.setCurrentEmailIndex(this.model.currentEmailIndex + 1);
                    this.readCurrentEmail();
                } catch (e) {
                    await this.speech.speak('Sorry, I could not mark that email as red.'); // Intentional: "red" not "read" for correct TTS pronunciation
                }
            }

            async archiveEmail() {
                this.speech.clearResumeState(); // Clear resume state when taking action on email
                this.view.updateStatus('Archiving email...');
                try {
                    await this.gmail.modifyEmail(this.model.currentEmail.id, [], ['INBOX', 'UNREAD']);
                    await this.speech.speak('Email archived.');
                    this.model.setCurrentEmailIndex(this.model.currentEmailIndex + 1);
                    this.readCurrentEmail();
                } catch (e) {
                    await this.speech.speak('Sorry, I could not archive that email.');
                }
            }

            async markAsSpam() {
                this.speech.clearResumeState(); // Clear resume state when taking action on email
                this.view.updateStatus('Marking as spam...');
                try {
                    await this.gmail.modifyEmail(this.model.currentEmail.id, ['SPAM'], ['INBOX', 'UNREAD']);
                    await this.speech.speak('Email marked as spam.');
                    this.model.setCurrentEmailIndex(this.model.currentEmailIndex + 1);
                    this.readCurrentEmail();
                } catch (e) {
                    await this.speech.speak('Sorry, I could not mark that email as spam.');
                }
            }

            // ========== REPLY FLOW ==========
            async handleReply() {
                const email = this.model.currentEmail;
                const from = EmailUtils.getHeader(email, 'From');
                const to = EmailUtils.getHeader(email, 'To');
                const cc = EmailUtils.getHeader(email, 'Cc');
                const senderName = from.replace(/<[^>]+>/, '').trim() || from;

                // Check if reply-all is an option
                const hasOthers = cc || (to && to.includes(','));
                let isReplyAll = false;

                if (hasOthers) {
                    this.model.setState('confirming-reply-type');
                    this.view.updateStatus('Choose reply type');
                    this.speech.speak('This email has other recipients. Say Reply to Sender Only, or Reply All to respond to everyone.');

                    const response = await this.waitForResponse();
                    isReplyAll = response.includes('all');
                }

                this.model.isReplyAll = isReplyAll;

                // Start dictation
                this.model.dictatedText = '';
                this.model.setState('dictating');
                this.view.updateStatus('Listening for response', `Start speaking your reply`);
                this.view.showDictation('', true);

                if (isReplyAll) {
                    this.speech.speak('What would you like to say in your response to the group?');
                } else {
                    this.speech.speak(`What would you like to say in your response to ${senderName}?`);
                }

                // Wait for dictation to complete
                const responseText = await this.waitForResponse();

                // Confirm
                this.model.dictatedText = responseText;
                this.model.setState('confirming-send');
                this.view.updateStatus('Confirm response');
                this.speech.speak(`You said: ${responseText}. Say Send to send, Edit to try again, or Cancel to go back.`);

                const confirmation = await this.waitForResponse();

                if (confirmation === 'send') {
                    this.view.hideDictation();
                    await this.sendReply(responseText, isReplyAll);
                } else if (confirmation === 'edit') {
                    this.view.hideDictation();
                    await this.handleReply(); // Retry
                } else {
                    this.view.hideDictation();
                    this.model.setState('idle');
                    this.view.updateStatus('Waiting for command');
                    this.speech.speak('Response cancelled. What would you like to do with this email?');
                }
            }

            async sendReply(text, isReplyAll) {
                this.view.updateStatus('Sending reply...');

                try {
                    const email = this.model.currentEmail;
                    const from = EmailUtils.getHeader(email, 'From');
                    const origTo = EmailUtils.getHeader(email, 'To');
                    const origCc = EmailUtils.getHeader(email, 'Cc');
                    const subject = EmailUtils.getHeader(email, 'Subject');
                    const messageId = EmailUtils.getHeader(email, 'Message-ID');
                    const references = EmailUtils.getHeader(email, 'References') || messageId;

                    let toRecipients = from;
                    let ccRecipients = '';

                    if (isReplyAll) {
                        const myEmail = await this.gmail.getMyEmail();

                        if (origTo) {
                            const others = origTo.split(',')
                                .map(a => a.trim())
                                .filter(a => !a.toLowerCase().includes(myEmail.toLowerCase()))
                                .filter(a => !a.toLowerCase().includes(from.toLowerCase().replace(/<[^>]+>/, '').trim()));
                            if (others.length) toRecipients += ', ' + others.join(', ');
                        }

                        if (origCc) {
                            const ccList = origCc.split(',')
                                .map(a => a.trim())
                                .filter(a => !a.toLowerCase().includes(myEmail.toLowerCase()));
                            if (ccList.length) ccRecipients = ccList.join(', ');
                        }
                    }

                    // Get original email info for quoting
                    const origDate = EmailUtils.getHeader(email, 'Date') || '';
                    const origBody = EmailUtils.getEmailBody(email);

                    // Format the quoted original message
                    const quotedLines = origBody.split('\n').map(line => '> ' + line).join('\n');
                    const quoteHeader = `On ${origDate}, ${from} wrote:`;

                    const replySubject = EmailUtils.encodeHeaderValue('Re: ' + subject);
                    const emailLines = [`To: ${toRecipients}`];
                    if (ccRecipients) emailLines.push(`Cc: ${ccRecipients}`);
                    emailLines.push(
                        `Subject: ${replySubject}`,
                        `In-Reply-To: ${messageId}`,
                        `References: ${references}`,
                        '',
                        text,
                        '',
                        quoteHeader,
                        quotedLines
                    );

                    await this.gmail.sendEmail(emailLines.join('\n'), email.threadId);

                    this.model.setState('idle');
                    this.view.updateStatus('Waiting for command');
                    this.speech.speak('Reply sent. What would you like to do with this email now?');
                } catch (e) {
                    console.error('Send reply error:', e);
                    this.speech.speak('Sorry, I could not send that reply.');
                    this.model.setState('idle');
                }
            }

            // ========== FORWARD FLOW ==========
            async handleForward() {
                this.view.updateStatus('Loading recent recipients...');
                const recipients = await this.gmail.getRecentRecipients(6);
                this.model.recentRecipients = recipients;

                this.model.setState('confirming-forward-recipient');
                this.view.updateStatus('Choose recipient');
                this.speech.speak('Who would you like to forward this email to?');

                const selectedRecipient = await this.waitForResponse();

                if (selectedRecipient === 'cancel') {
                    this.model.setState('idle');
                    this.view.updateStatus('Waiting for command');
                    this.speech.speak('Forward cancelled. What would you like to do with this email?');
                    return;
                }

                // Extract email address
                const match = selectedRecipient.match(/<([^>]+)>/);
                const emailAddress = match ? match[1] : selectedRecipient;

                // Confirm recipient
                this.model.setState('confirming-forward');
                this.view.updateStatus('Confirm recipient', `Forward to ${emailAddress}?`);
                this.speech.speak(`Forward to ${emailAddress}. Say Yes to confirm, or No to cancel.`);

                const confirmation = await this.waitForResponse();

                if (confirmation.includes('yes')) {
                    await this.forwardEmail(emailAddress);
                } else {
                    this.model.setState('idle');
                    this.view.updateStatus('Waiting for command');
                    this.speech.speak('Forward cancelled. What would you like to do with this email?');
                }
            }

            async forwardEmail(toAddress) {
                // Ask about adding a message
                this.model.setState('confirming-forward-message');
                this.view.updateStatus('Add message?');
                this.speech.speak('Would you like to add a message to this forward? Say Yes or No.');

                const wantsMessage = await this.waitForResponse();
                let forwardMessage = '';

                if (wantsMessage.includes('yes')) {
                    // Get message via dictation
                    this.model.dictatedText = '';
                    this.model.setState('dictating');
                    this.view.updateStatus('Listening for message');
                    this.view.showDictation('', true);
                    this.speech.speak('What would you like to say in your message?');

                    forwardMessage = await this.waitForResponse();

                    // Confirm
                    this.model.dictatedText = forwardMessage;
                    this.model.setState('confirming-send');
                    this.view.updateStatus('Confirm forward');
                    this.speech.speak(`You said: ${forwardMessage}. Say Send to forward with this message, Edit to try again, or Cancel to go back.`);

                    const confirmation = await this.waitForResponse();
                    this.view.hideDictation();

                    if (confirmation === 'edit') {
                        return await this.forwardEmail(toAddress);
                    } else if (confirmation !== 'send') {
                        this.model.setState('idle');
                        this.view.updateStatus('Waiting for command');
                        this.speech.speak('Forward cancelled. What would you like to do with this email?');
                        return;
                    }
                }

                // Send the forward
                this.view.updateStatus('Forwarding email...');

                try {
                    const email = this.model.currentEmail;
                    const subject = EmailUtils.getHeader(email, 'Subject');
                    const body = EmailUtils.getEmailBody(email);

                    const fwdSubject = EmailUtils.encodeHeaderValue('Fwd: ' + subject);
                    const emailParts = [
                        `To: ${toAddress}`,
                        `Subject: ${fwdSubject}`,
                        ''
                    ];

                    if (forwardMessage) {
                        emailParts.push(forwardMessage);
                        emailParts.push('');
                    }

                    emailParts.push('---------- Forwarded message ---------');
                    emailParts.push(body);

                    await this.gmail.sendEmail(emailParts.join('\n'));

                    this.model.setState('idle');
                    this.view.updateStatus('Waiting for command');
                    this.speech.speak('Email forwarded. What would you like to do with this email now?');
                } catch (e) {
                    console.error('Forward error:', e);
                    this.speech.speak('Sorry, I could not forward that email.');
                    this.model.setState('idle');
                }
            }

            // ========== UNSUBSCRIBE ==========
            async handleUnsubscribe() {
                this.speech.clearResumeState(); // Clear resume state when taking action on email
                const fullBody = EmailUtils.extractFullBody(this.model.currentEmail.payload);
                const match = fullBody.match(/https?:\/\/[^\s<>"]+unsubscribe[^\s<>"]*/i);

                if (match) {
                    await this.speech.speak('I found an unsubscribe link. I will click it. You may need to take some action in your browser.');
                    this.view.updateStatus('Opening unsubscribe link...');
                    window.open(match[0], '_blank');
                } else {
                    await this.speech.speak('I could not find an unsubscribe link in this email. Marking as red so you can find it later.'); // Intentional: "red" not "read" for correct TTS pronunciation
                }

                await this.gmail.modifyEmail(this.model.currentEmail.id, [], ['UNREAD']);
                await this.speech.speak('Marked as red. Moving to next email.'); // Intentional: "red" not "read" for correct TTS pronunciation
                this.model.setCurrentEmailIndex(this.model.currentEmailIndex + 1);
                this.readCurrentEmail();
            }

            // ========== ATTACHMENTS ==========
            hasReadableAttachments() {
                if (!this.model.currentEmail) return false;
                const attachments = EmailUtils.getAttachments(this.model.currentEmail);
                return attachments.some(att => EmailUtils.isReadableAttachment(att));
            }

            getReadableAttachments() {
                if (!this.model.currentEmail) return [];
                const attachments = EmailUtils.getAttachments(this.model.currentEmail);
                return attachments.filter(att => EmailUtils.isReadableAttachment(att));
            }

            async readAttachments() {
                const readableAttachments = this.getReadableAttachments();

                if (readableAttachments.length === 0) {
                    await this.speech.speak('This email has no readable attachments.');
                    return;
                }

                // Set state so Stop button appears and Read Attachments button hides
                this.model.setState('reading-attachment');
                this.view.updateStatus('Reading attachments...');

                for (let i = 0; i < readableAttachments.length; i++) {
                    // Check if user said "Stop" (state would change from 'reading-attachment')
                    if (this.model.state !== 'reading-attachment') {
                        this.view.updateStatus('Stopped reading attachments');
                        return;
                    }

                    const attachment = readableAttachments[i];
                    const position = readableAttachments.length > 1 ? `Attachment ${i + 1} of ${readableAttachments.length}. ` : '';

                    await this.speech.speak(`${position}Reading ${attachment.filename}. Please wait while I extract the text.`);
                    this.view.updateStatus(`Reading ${attachment.filename}...`);

                    const result = await this.gmail.extractAttachmentText(
                        this.model.currentEmail.id,
                        attachment
                    );

                    // Check again after extraction in case user said "Stop" during the wait
                    if (this.model.state !== 'reading-attachment') {
                        this.view.updateStatus('Stopped reading attachments');
                        return;
                    }

                    if (result.success) {
                        const textToRead = result.text;
                        await this.speech.speak(`Content of ${attachment.filename}: ${textToRead}`);
                    } else {
                        await this.speech.speak(`Sorry, I could not read ${attachment.filename}. ${result.error}`);
                    }
                }

                this.view.updateStatus('Finished reading attachments');
                await this.speech.speak('Finished reading attachments. What would you like to do with this email?');
                this.model.setState('idle');
            }
        }

        // ============================================================
        // APP INITIALIZATION
        // ============================================================
        const model = new EmailReaderModel();
        const view = new EmailReaderView();
        const gmail = new GmailService(model);
        const speech = new SpeechService();
        const app = new EmailReaderController(model, view, gmail, speech);

        window.onload = () => {
            app.init();

            // Timeout check: if still initializing after 8 seconds, show error
            setTimeout(() => {
                if (model.state === 'initializing') {
                    console.error('Timeout: Google Identity Services may be blocked');
                    const ctaEl = document.querySelector('.welcome-cta');
                    if (ctaEl) {
                        ctaEl.innerHTML = '⚠️ Google sign-in is not loading.<br><br>This may be caused by content blockers or your browser privacy settings.<br><br>Try disabling pop-up blockers for this site, or use a different browser instead.';
                        ctaEl.style.fontSize = '18px';
                    }
                }
            }, 8000);
        };
    </script>
</body>
</html>
